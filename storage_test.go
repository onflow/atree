/*
 * Atree - Scalable Arrays and Ordered Maps
 *
 * Copyright Flow Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package atree_test

import (
	"encoding/binary"
	"errors"
	"math/rand"
	"runtime"
	"strings"
	"testing"

	"github.com/fxamacker/cbor/v2"
	"github.com/stretchr/testify/require"

	"github.com/onflow/atree"
	"github.com/onflow/atree/test_utils"
)

func TestStorageIndexNext(t *testing.T) {
	index := atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}
	want := atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2}
	require.Equal(t, want, index.Next())
}

func TestNewSlabID(t *testing.T) {
	t.Run("temp address", func(t *testing.T) {
		require.True(t, atree.NewSlabID(atree.Address{}, atree.SlabIndex{1}).HasTempAddress())
	})
	t.Run("perm address", func(t *testing.T) {
		require.False(t, atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1}).HasTempAddress())
	})
}

func TestNewSlabIDFromRawBytes(t *testing.T) {
	t.Run("data length < slab id size", func(t *testing.T) {
		var fatalError *atree.FatalError
		var slabIDError *atree.SlabIDError

		id, err := atree.NewSlabIDFromRawBytes(nil)
		require.Equal(t, atree.SlabIDUndefined, id)
		require.Equal(t, 1, errorCategorizationCount(err))
		require.ErrorAs(t, err, &fatalError)
		require.ErrorAs(t, err, &slabIDError)
		require.ErrorAs(t, fatalError, &slabIDError)

		id, err = atree.NewSlabIDFromRawBytes([]byte{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2})
		require.Equal(t, atree.SlabIDUndefined, id)
		require.Equal(t, 1, errorCategorizationCount(err))
		require.ErrorAs(t, err, &fatalError)
		require.ErrorAs(t, err, &slabIDError)
		require.ErrorAs(t, fatalError, &slabIDError)
	})

	t.Run("data length == slab id size", func(t *testing.T) {
		id, err := atree.NewSlabIDFromRawBytes([]byte{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2})

		want := atree.NewSlabID(
			atree.Address{0, 0, 0, 0, 0, 0, 0, 1},
			atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2},
		)
		require.Equal(t, want, id)
		require.NoError(t, err)
	})
	t.Run("data length > slab id size", func(t *testing.T) {
		id, err := atree.NewSlabIDFromRawBytes([]byte{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 1, 2, 3, 4, 5, 6, 7, 8})

		want := atree.NewSlabID(
			atree.Address{0, 0, 0, 0, 0, 0, 0, 1},
			atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2},
		)
		require.Equal(t, want, id)
		require.NoError(t, err)
	})
}

func TestSlabIDToRawBytes(t *testing.T) {
	t.Run("buffer nil", func(t *testing.T) {
		var fatalError *atree.FatalError
		var slabIDError *atree.SlabIDError

		size, err := atree.SlabIDUndefined.ToRawBytes(nil)
		require.Equal(t, 0, size)
		require.Equal(t, 1, errorCategorizationCount(err))
		require.ErrorAs(t, err, &fatalError)
		require.ErrorAs(t, err, &slabIDError)
		require.ErrorAs(t, fatalError, &slabIDError)
	})

	t.Run("buffer too short", func(t *testing.T) {
		var fatalError *atree.FatalError
		var slabIDError *atree.SlabIDError

		b := make([]byte, 8)
		size, err := atree.SlabIDUndefined.ToRawBytes(b)
		require.Equal(t, 0, size)
		require.Equal(t, 1, errorCategorizationCount(err))
		require.ErrorAs(t, err, &fatalError)
		require.ErrorAs(t, err, &slabIDError)
		require.ErrorAs(t, fatalError, &slabIDError)
	})

	t.Run("undefined", func(t *testing.T) {
		b := make([]byte, atree.SlabIDLength)
		size, err := atree.SlabIDUndefined.ToRawBytes(b)
		require.NoError(t, err)

		want := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		require.Equal(t, want, b)
		require.Equal(t, atree.SlabIDLength, size)
	})

	t.Run("temp address", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{0, 0, 0, 0, 0, 0, 0, 0}, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		b := make([]byte, atree.SlabIDLength)
		size, err := id.ToRawBytes(b)
		require.NoError(t, err)

		want := []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
		require.Equal(t, want, b)
		require.Equal(t, atree.SlabIDLength, size)
	})

	t.Run("temp index", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{0, 0, 0, 0, 0, 0, 0, 1}, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 0})
		b := make([]byte, atree.SlabIDLength)
		size, err := id.ToRawBytes(b)
		require.NoError(t, err)

		want := []byte{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}
		require.Equal(t, want, b)
		require.Equal(t, atree.SlabIDLength, size)
	})

	t.Run("perm", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{0, 0, 0, 0, 0, 0, 0, 1}, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		b := make([]byte, atree.SlabIDLength)
		size, err := id.ToRawBytes(b)
		require.NoError(t, err)

		want := []byte{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2}
		require.Equal(t, want, b)
		require.Equal(t, atree.SlabIDLength, size)
	})
}

func TestSlabIDAddressAsUint64(t *testing.T) {
	t.Run("temp", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{}, atree.SlabIndex{1})
		require.Equal(t, uint64(0), id.AddressAsUint64())
	})
	t.Run("perm", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{0, 0, 0, 0, 0, 0, 0, 1}, atree.SlabIndex{1})
		require.Equal(t, uint64(1), id.AddressAsUint64())
	})
}

func TestSlabIDAddress(t *testing.T) {
	t.Run("temp", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{}, atree.SlabIndex{1})
		require.Equal(t, atree.Address{}, id.Address())
	})
	t.Run("perm", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{0, 0, 0, 0, 0, 0, 0, 1}, atree.SlabIndex{1})
		require.Equal(t, atree.Address{0, 0, 0, 0, 0, 0, 0, 1}, id.Address())
	})
}

func TestSlabIDIndexAsUint64(t *testing.T) {
	t.Run("temp", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{}, atree.SlabIndex{})
		require.Equal(t, uint64(0), id.IndexAsUint64())
	})
	t.Run("perm", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{}, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		require.Equal(t, uint64(1), id.IndexAsUint64())
	})
}

func TestSlabIDValid(t *testing.T) {
	t.Run("undefined", func(t *testing.T) {
		id := atree.SlabIDUndefined
		err := id.Valid()

		var fatalError *atree.FatalError
		var slabIDError *atree.SlabIDError
		require.Equal(t, 1, errorCategorizationCount(err))
		require.ErrorAs(t, err, &fatalError)
		require.ErrorAs(t, err, &slabIDError)
		require.ErrorAs(t, fatalError, &slabIDError)
	})

	t.Run("temp index", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{1}, atree.SlabIndexUndefined)
		err := id.Valid()

		var fatalError *atree.FatalError
		var slabIDError *atree.SlabIDError
		require.Equal(t, 1, errorCategorizationCount(err))
		require.ErrorAs(t, err, &fatalError)
		require.ErrorAs(t, err, &slabIDError)
		require.ErrorAs(t, fatalError, &slabIDError)
	})

	t.Run("temp address", func(t *testing.T) {
		id := atree.NewSlabID(atree.AddressUndefined, atree.SlabIndex{1})
		require.NoError(t, id.Valid())
	})

	t.Run("valid", func(t *testing.T) {
		id := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{2})
		require.NoError(t, id.Valid())
	})
}

func TestSlabIDCompare(t *testing.T) {
	t.Run("same", func(t *testing.T) {
		id1 := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
		id2 := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
		require.Equal(t, 0, id1.Compare(id2))
		require.Equal(t, 0, id2.Compare(id1))
	})

	t.Run("different address", func(t *testing.T) {
		id1 := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
		id2 := atree.NewSlabID(atree.Address{2}, atree.SlabIndex{1})
		require.Equal(t, -1, id1.Compare(id2))
		require.Equal(t, 1, id2.Compare(id1))
	})

	t.Run("different index", func(t *testing.T) {
		id1 := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
		id2 := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{2})
		require.Equal(t, -1, id1.Compare(id2))
		require.Equal(t, 1, id2.Compare(id1))
	})

	t.Run("different address and index", func(t *testing.T) {
		id1 := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
		id2 := atree.NewSlabID(atree.Address{2}, atree.SlabIndex{2})
		require.Equal(t, -1, id1.Compare(id2))
		require.Equal(t, 1, id2.Compare(id1))
	})
}

func TestLedgerBaseStorageStore(t *testing.T) {
	ledger := newTestLedger()
	baseStorage := atree.NewLedgerBaseStorage(ledger)

	bytesStored := 0
	values := map[atree.SlabID][]byte{
		atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1}): {1, 2, 3},
		atree.NewSlabID(atree.Address{1}, atree.SlabIndex{2}): {4, 5, 6},
	}

	// Store values
	for id, value := range values {
		err := baseStorage.Store(id, value)
		bytesStored += len(value)
		require.NoError(t, err)
	}

	// Overwrite stored values
	for id := range values {
		values[id] = append(values[id], []byte{1, 2, 3}...)
		bytesStored += len(values[id])
		err := baseStorage.Store(id, values[id])
		require.NoError(t, err)
	}

	require.Equal(t, bytesStored, baseStorage.BytesStored())
	require.Equal(t, 0, baseStorage.BytesRetrieved())

	iterator := ledger.Iterator()

	count := 0
	for {
		owner, key, value := iterator()
		if owner == nil {
			break
		}

		id := NewSlabIDFromRawAddressAndIndex(owner, key[1:])

		require.True(t, atree.LedgerKeyIsSlabKey(string(key)))
		require.Equal(t, values[id], value)

		count++
	}
	require.Equal(t, len(values), count)
}

func TestLedgerBaseStorageRetrieve(t *testing.T) {
	ledger := newTestLedger()
	baseStorage := atree.NewLedgerBaseStorage(ledger)

	id := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
	value := []byte{1, 2, 3}
	bytesStored := 0
	bytesRetrieved := 0

	// Retrieve value from empty storage
	b, found, err := baseStorage.Retrieve(id)
	require.NoError(t, err)
	require.False(t, found)
	require.Equal(t, 0, len(b))

	bytesStored += len(value)
	err = baseStorage.Store(id, value)
	require.NoError(t, err)

	// Retrieve stored value
	b, found, err = baseStorage.Retrieve(id)
	bytesRetrieved += len(b)
	require.NoError(t, err)
	require.True(t, found)
	require.Equal(t, value, b)

	// Retrieve non-existent value
	id = atree.NewSlabID(atree.Address{1}, atree.SlabIndex{2})
	b, found, err = baseStorage.Retrieve(id)
	require.NoError(t, err)
	require.False(t, found)
	require.Nil(t, b)

	require.Equal(t, bytesStored, baseStorage.BytesStored())
	require.Equal(t, bytesRetrieved, baseStorage.BytesRetrieved())
}

func TestLedgerBaseStorageRemove(t *testing.T) {
	ledger := newTestLedger()
	baseStorage := atree.NewLedgerBaseStorage(ledger)

	id := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
	value := []byte{1, 2, 3}

	// Remove value from empty storage
	err := baseStorage.Remove(id)
	require.NoError(t, err)

	err = baseStorage.Store(id, value)
	require.NoError(t, err)

	// Remove stored value
	err = baseStorage.Remove(id)
	require.NoError(t, err)

	// Remove removed value
	err = baseStorage.Remove(id)
	require.NoError(t, err)

	// Remove non-existent value
	err = baseStorage.Remove(atree.NewSlabID(id.Address(), id.Index().Next()))
	require.NoError(t, err)

	// Retrieve removed value
	slab, found, err := baseStorage.Retrieve(id)
	require.NoError(t, err)
	require.False(t, found)
	require.Nil(t, slab)

	iterator := ledger.Iterator()

	count := 0
	for {
		owner, key, value := iterator()
		if owner == nil {
			break
		}

		require.True(t, atree.LedgerKeyIsSlabKey(string(key)))
		require.Nil(t, value)

		count++
	}
	require.Equal(t, 2, count)
}

func TestLedgerBaseStorageGenerateSlabID(t *testing.T) {
	ledger := newTestLedger()
	baseStorage := atree.NewLedgerBaseStorage(ledger)

	address1 := atree.Address{1}
	address2 := atree.Address{2}

	id, err := baseStorage.GenerateSlabID(address1)
	require.NoError(t, err)
	require.Equal(t, address1, id.Address())
	require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}, id.Index())

	id, err = baseStorage.GenerateSlabID(address1)
	require.NoError(t, err)
	require.Equal(t, address1, id.Address())
	require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2}, id.Index())

	id, err = baseStorage.GenerateSlabID(address2)
	require.NoError(t, err)
	require.Equal(t, address2, id.Address())
	require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}, id.Index())
}

func TestBasicSlabStorageStore(t *testing.T) {
	storage := atree.NewBasicSlabStorage(nil, nil, nil, nil)

	r := newRand(t)
	address := atree.Address{1}
	slabs := map[atree.SlabID]atree.Slab{
		atree.NewSlabID(address, atree.SlabIndex{1}): generateRandomSlab(atree.NewSlabID(address, atree.SlabIndex{1}), r),
		atree.NewSlabID(address, atree.SlabIndex{2}): generateRandomSlab(atree.NewSlabID(address, atree.SlabIndex{2}), r),
	}

	// Store values
	for id, slab := range slabs {
		err := storage.Store(id, slab)
		require.NoError(t, err)
	}

	// Overwrite stored values
	for id := range slabs {
		slab := generateRandomSlab(id, r)
		slabs[id] = slab
		err := storage.Store(id, slab)
		require.NoError(t, err)
	}

	require.Equal(t, len(slabs), storage.Count())

	// Retrieve slabs
	for id, want := range slabs {
		slab, found, err := storage.Retrieve(id)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, want, slab)
	}
}

func TestBasicSlabStorageRetrieve(t *testing.T) {
	storage := atree.NewBasicSlabStorage(nil, nil, nil, nil)

	r := newRand(t)
	id := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
	slab := generateRandomSlab(id, r)

	// Retrieve value from empty storage
	retrievedSlab, found, err := storage.Retrieve(id)
	require.NoError(t, err)
	require.False(t, found)
	require.Nil(t, retrievedSlab)

	err = storage.Store(id, slab)
	require.NoError(t, err)

	// Retrieve stored value
	retrievedSlab, found, err = storage.Retrieve(id)
	require.NoError(t, err)
	require.True(t, found)
	require.Equal(t, slab, retrievedSlab)

	// Retrieve non-existent value
	id = atree.NewSlabID(atree.Address{1}, atree.SlabIndex{2})
	retrievedSlab, found, err = storage.Retrieve(id)
	require.NoError(t, err)
	require.False(t, found)
	require.Nil(t, retrievedSlab)
}

func TestBasicSlabStorageRemove(t *testing.T) {
	storage := atree.NewBasicSlabStorage(nil, nil, nil, nil)

	r := newRand(t)
	id := atree.NewSlabID(atree.Address{1}, atree.SlabIndex{1})
	slab := generateRandomSlab(id, r)

	// Remove value from empty storage
	err := storage.Remove(id)
	require.NoError(t, err)

	err = storage.Store(id, slab)
	require.NoError(t, err)

	// Remove stored value
	err = storage.Remove(id)
	require.NoError(t, err)

	// Remove removed value
	err = storage.Remove(id)
	require.NoError(t, err)

	// Remove non-existent value
	err = storage.Remove(atree.NewSlabID(id.Address(), id.Index().Next()))
	require.NoError(t, err)

	// Retrieve removed value
	slab, found, err := storage.Retrieve(id)
	require.NoError(t, err)
	require.False(t, found)
	require.Nil(t, slab)

	require.Equal(t, 0, storage.Count())
}

func TestBasicSlabStorageGenerateSlabID(t *testing.T) {
	storage := atree.NewBasicSlabStorage(nil, nil, nil, nil)

	address1 := atree.Address{1}
	address2 := atree.Address{2}

	id, err := storage.GenerateSlabID(address1)
	require.NoError(t, err)
	require.Equal(t, address1, id.Address())
	require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}, id.Index())

	id, err = storage.GenerateSlabID(address1)
	require.NoError(t, err)
	require.Equal(t, address1, id.Address())
	require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2}, id.Index())

	id, err = storage.GenerateSlabID(address2)
	require.NoError(t, err)
	require.Equal(t, address2, id.Address())
	require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}, id.Index())
}

func TestBasicSlabStorageSlabIDs(t *testing.T) {
	r := newRand(t)
	address := atree.Address{1}
	index := atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 0}
	wantIDs := map[atree.SlabID]bool{
		atree.NewSlabID(address, index.Next()): true,
		atree.NewSlabID(address, index.Next()): true,
		atree.NewSlabID(address, index.Next()): true,
	}

	storage := atree.NewBasicSlabStorage(nil, nil, nil, nil)

	// Get slab ids from empty storgae
	ids := storage.SlabIDs()
	require.Equal(t, 0, len(ids))

	// Store values
	for id := range wantIDs {
		err := storage.Store(id, generateRandomSlab(id, r))
		require.NoError(t, err)
	}

	// Get slab ids from non-empty storgae
	ids = storage.SlabIDs()
	require.Equal(t, len(wantIDs), len(ids))

	for _, id := range ids {
		require.True(t, wantIDs[id])
	}
}

func TestBasicSlabStorageSlabIterat(t *testing.T) {
	r := newRand(t)
	address := atree.Address{1}
	index := atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 0}

	id1 := atree.NewSlabID(address, index.Next())
	id2 := atree.NewSlabID(address, index.Next())
	id3 := atree.NewSlabID(address, index.Next())

	want := map[atree.SlabID]atree.Slab{
		id1: generateRandomSlab(id1, r),
		id2: generateRandomSlab(id2, r),
		id3: generateRandomSlab(id3, r),
	}

	storage := atree.NewBasicSlabStorage(nil, nil, nil, nil)

	// Store values
	for id, slab := range want {
		err := storage.Store(id, slab)
		require.NoError(t, err)
	}

	iterator, err := storage.SlabIterator()
	require.NoError(t, err)

	count := 0
	for {
		id, slab := iterator()
		if id == atree.SlabIDUndefined {
			break
		}
		require.NotNil(t, want[id])
		require.Equal(t, want[id], slab)
		count++
	}
	require.Equal(t, len(want), count)
}

func TestPersistentStorage(t *testing.T) {

	encMode, err := cbor.EncOptions{}.EncMode()
	require.NoError(t, err)

	decMode, err := cbor.DecOptions{}.DecMode()
	require.NoError(t, err)

	tempAddress := atree.Address{}
	permAddress := atree.Address{1, 0, 0, 0, 0, 0, 0, 0}

	t.Run("empty storage", func(t *testing.T) {
		baseStorage := test_utils.NewInMemBaseStorage()
		storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, nil, nil)

		slabIndex := atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}

		tempSlabID := atree.NewSlabID(tempAddress, slabIndex)

		permSlabID := atree.NewSlabID(permAddress, slabIndex)

		_, found, err := storage.Retrieve(tempSlabID)
		require.NoError(t, err)
		require.False(t, found)

		_, found, err = storage.Retrieve(permSlabID)
		require.NoError(t, err)
		require.False(t, found)

		require.Equal(t, uint(0), storage.DeltasWithoutTempAddresses())
		require.Equal(t, uint(0), storage.Deltas())
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
		require.False(t, storage.HasUnsavedChanges(tempAddress))
		require.False(t, storage.HasUnsavedChanges(permAddress))
	})

	t.Run("temp address", func(t *testing.T) {

		r := newRand(t)

		baseStorage := test_utils.NewInMemBaseStorage()
		storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, nil, nil)

		slabIndex := atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}

		tempSlabID := atree.NewSlabID(tempAddress, slabIndex)

		permSlabID := atree.NewSlabID(permAddress, slabIndex)

		slab1 := generateRandomSlab(tempSlabID, r)
		slab2 := generateRandomSlab(permSlabID, r)

		// no temp ids should be in the base storage
		err = storage.Store(tempSlabID, slab1)
		require.NoError(t, err)

		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
		require.True(t, storage.HasUnsavedChanges(tempAddress))
		require.False(t, storage.HasUnsavedChanges(permAddress))

		err = storage.Store(permSlabID, slab2)
		require.NoError(t, err)

		require.Equal(t, uint(1), storage.DeltasWithoutTempAddresses())
		require.Equal(t, uint(2), storage.Deltas())
		require.True(t, storage.DeltasSizeWithoutTempAddresses() > 0)
		require.Equal(t, uint64(slab2.ByteSize()), storage.DeltasSizeWithoutTempAddresses())
		require.True(t, storage.HasUnsavedChanges(tempAddress))
		require.True(t, storage.HasUnsavedChanges(permAddress))

		err = storage.Commit()
		require.NoError(t, err)

		require.Equal(t, uint(0), storage.DeltasWithoutTempAddresses())
		require.Equal(t, uint(1), storage.Deltas())
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
		require.True(t, storage.HasUnsavedChanges(tempAddress)) // Temp slabs are still in deltas after commit.
		require.False(t, storage.HasUnsavedChanges(permAddress))

		// Slab with temp slab id is NOT persisted in base storage.
		_, found, err := baseStorage.Retrieve(tempSlabID)
		require.NoError(t, err)
		require.False(t, found)

		// Slab with temp slab id is cached in storage.
		_, found, err = storage.Retrieve(tempSlabID)
		require.NoError(t, err)
		require.True(t, found)

		// Slab with perm slab id is persisted in base storage.
		_, found, err = baseStorage.Retrieve(permSlabID)
		require.NoError(t, err)
		require.True(t, found)

		// Slab with perm slab id is cached in storage.
		_, found, err = storage.Retrieve(permSlabID)
		require.NoError(t, err)
		require.True(t, found)

		// Remove slab with perm slab id
		err = storage.Remove(permSlabID)
		require.NoError(t, err)

		require.True(t, storage.HasUnsavedChanges(tempAddress))
		require.True(t, storage.HasUnsavedChanges(permAddress))

		// Remove slab with temp slab id
		err = storage.Remove(tempSlabID)
		require.NoError(t, err)

		require.Equal(t, uint(1), storage.DeltasWithoutTempAddresses())
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
		require.True(t, storage.HasUnsavedChanges(tempAddress))
		require.True(t, storage.HasUnsavedChanges(permAddress))

		err = storage.Commit()
		require.NoError(t, err)

		require.True(t, storage.HasUnsavedChanges(tempAddress))
		require.False(t, storage.HasUnsavedChanges(permAddress))

		// Slab with perm slab id is removed from base storage.
		_, found, err = baseStorage.Retrieve(permSlabID)
		require.NoError(t, err)
		require.False(t, found)

		// Slab with perm slab id is removed from cache in storage.
		_, found, err = storage.Retrieve(permSlabID)
		require.NoError(t, err)
		require.False(t, found)

		// Slab with temp slab id is removed from cache in storage.
		_, found, err = storage.Retrieve(tempSlabID)
		require.NoError(t, err)
		require.False(t, found)

		require.Equal(t, uint(0), storage.DeltasWithoutTempAddresses())
		require.Equal(t, uint(1), storage.Deltas())
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
	})

	t.Run("commit", func(t *testing.T) {
		const (
			numberOfAccounts        = 100
			numberOfSlabsPerAccount = 10
		)

		r := newRand(t)

		baseStorage := newAccessOrderTrackerBaseStorage()
		storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, nil, nil)

		baseStorage2 := newAccessOrderTrackerBaseStorage()
		storageWithFastCommit := atree.NewPersistentSlabStorage(baseStorage2, encMode, decMode, nil, nil)

		simpleMap := make(map[atree.SlabID][]byte)
		slabSize := uint64(0)
		// test random updates apply commit and check the order of committed values
		for range numberOfAccounts {
			for range numberOfSlabsPerAccount {
				addr := generateRandomAddress(r)

				slabID, err := storage.GenerateSlabID(addr)
				require.NoError(t, err)

				slab := generateRandomSlab(slabID, r)
				slabSize += uint64(slab.ByteSize())

				err = storage.Store(slabID, slab)
				require.NoError(t, err)

				slabID2, err := storageWithFastCommit.GenerateSlabID(addr)
				require.NoError(t, err)

				err = storageWithFastCommit.Store(slabID2, slab)
				require.NoError(t, err)

				// capture data for accuracy testing
				simpleMap[slabID], err = atree.EncodeSlab(slab, encMode)
				require.NoError(t, err)
			}
		}

		require.True(t, storage.DeltasSizeWithoutTempAddresses() > 0)
		require.Equal(t, slabSize, storage.DeltasSizeWithoutTempAddresses())
		require.True(t, storageWithFastCommit.DeltasSizeWithoutTempAddresses() > 0)
		require.Equal(t, slabSize, storageWithFastCommit.DeltasSizeWithoutTempAddresses())

		err = storage.Commit()
		require.NoError(t, err)
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())

		err = storageWithFastCommit.FastCommit(10)
		require.NoError(t, err)
		require.Equal(t, uint64(0), storageWithFastCommit.DeltasSizeWithoutTempAddresses())

		require.Equal(t, len(simpleMap), storage.Count())
		require.Equal(t, len(simpleMap), storageWithFastCommit.Count())

		// check update functionality
		for sid, value := range simpleMap {
			storedValue, found, err := baseStorage.Retrieve(sid)
			require.NoError(t, err)
			require.True(t, found)
			require.Equal(t, value, storedValue)

			storedValue, found, err = baseStorage2.Retrieve(sid)
			require.NoError(t, err)
			require.True(t, found)
			require.Equal(t, value, storedValue)
		}

		// compare orders
		require.Equal(t, baseStorage.SegTouchOrder(), baseStorage2.SegTouchOrder())

		// remove all slabs from storage
		for sid := range simpleMap {
			err = storage.Remove(sid)
			require.NoError(t, err)
			require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())

			err = storageWithFastCommit.Remove(sid)
			require.NoError(t, err)
			require.Equal(t, uint64(0), storageWithFastCommit.DeltasSizeWithoutTempAddresses())
		}

		require.Equal(t, uint(len(simpleMap)), storage.DeltasWithoutTempAddresses())
		require.Equal(t, uint(len(simpleMap)), storageWithFastCommit.DeltasWithoutTempAddresses())

		err = storage.Commit()
		require.NoError(t, err)

		err = storageWithFastCommit.FastCommit(10)
		require.NoError(t, err)

		require.Equal(t, 0, storage.Count())
		require.Equal(t, 0, storageWithFastCommit.Count())
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
		require.Equal(t, uint64(0), storageWithFastCommit.DeltasSizeWithoutTempAddresses())

		// check remove functionality
		for sid := range simpleMap {
			storedValue, found, err := storage.Retrieve(sid)
			require.NoError(t, err)
			require.False(t, found)
			require.Nil(t, storedValue)

			storedValue, found, err = storageWithFastCommit.Retrieve(sid)
			require.NoError(t, err)
			require.False(t, found)
			require.Nil(t, storedValue)
		}

		// compare orders
		require.Equal(t, baseStorage.SegTouchOrder(), baseStorage2.SegTouchOrder())
	})

	t.Run("commit with error", func(t *testing.T) {

		baseStorage := test_utils.NewInMemBaseStorage()
		storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, nil, nil)

		address := atree.Address{1}

		id, err := storage.GenerateSlabID(address)
		require.NoError(t, err)

		// Encoding slabWithNonStorable returns error.
		slabWithNonStorable := atree.NewArrayRootDataSlab(id, []atree.Storable{nonStorable{}})

		err = storage.Store(id, slabWithNonStorable)
		require.NoError(t, err)

		for range 500 {
			id, err := storage.GenerateSlabID(address)
			require.NoError(t, err)

			// Encoding slabWithSlowStorable takes some time which delays
			// sending encoding result to results channel.
			slabWithSlowStorable := atree.NewArrayRootDataSlab(id, []atree.Storable{newSlowStorable(1)})

			err = storage.Store(id, slabWithSlowStorable)
			require.NoError(t, err)
		}

		err = storage.FastCommit(2)
		require.Equal(t, 1, errorCategorizationCount(err))

		var externalError *atree.ExternalError
		require.ErrorAs(t, err, &externalError)
		require.ErrorIs(t, err, errEncodeNonStorable)
		require.ErrorIs(t, externalError.Unwrap(), errEncodeNonStorable)
	})
}

func TestPersistentStorageSlabIterator(t *testing.T) {
	t.Run("empty storage", func(t *testing.T) {
		storage := newTestPersistentStorage(t)

		iterator, err := storage.SlabIterator()
		require.NoError(t, err)

		count := 0
		for {
			id, _ := iterator()
			if id == atree.SlabIDUndefined {
				break
			}
			count++
		}
		require.Equal(t, 0, count)
	})

	t.Run("not-empty storage", func(t *testing.T) {

		address := atree.Address{1, 2, 3, 4, 5, 6, 7, 8}
		id1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		id2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		id3 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})
		id4 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		data := map[atree.SlabID][]byte{
			// (metadata slab) headers: [{id:2 size:228 count:9} {id:3 size:270 count:11} ]
			id1: {
				// version
				0x10,
				// extra data flag
				0x81,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// child shared storage address
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				// child header count
				0x00, 0x02,
				// child header 1 (slab id, count, size)
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x09,
				0x00, 0xe4,
				// child header 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x0b,
				0x01, 0x0e,
			},

			// (data slab) next: 3, data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			id2: {
				// version
				0x12,
				// array data slab flag
				0x00,
				// next slab id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x09,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},

			// (data slab) next: 0, data: [aaaaaaaaaaaaaaaaaaaaaa ... atree.SlabID(...)]
			id3: {
				// version
				0x10,
				// array data slab flag
				0x40,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x0b,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},

			// (data slab) next: 0, data: [0]
			id4: {
				// version
				0x10,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2b,

				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		_, err := atree.NewArrayWithRootID(storage, id1)
		require.NoError(t, err)

		iterator, err := storage.SlabIterator()
		require.NoError(t, err)

		count := 0
		for {
			id, slab := iterator()
			if id == atree.SlabIDUndefined {
				break
			}

			encodedSlab, err := atree.EncodeSlab(slab, atree.GetCBOREncMode(storage))
			require.NoError(t, err)

			require.Equal(t, encodedSlab, data[id])
			count++
		}
		require.Equal(t, len(data), count)
	})

	t.Run("not-empty storage with some slabs in deltas", func(t *testing.T) {

		address := atree.Address{1, 2, 3, 4, 5, 6, 7, 8}
		id1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		id2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		originalData := map[atree.SlabID][]byte{
			// (data slab) data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			id1: {
				// version
				0x10,
				// flag
				0xc0,
				// array extra data
				0x81,
				// type info
				0x18, 0x2a,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x14,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			// (data slab) next: 0, data: [0]
			id2: {
				// version
				0x10,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2b,

				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		modifiedData := map[atree.SlabID][]byte{
			// (data slab) data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			id1: {
				// version
				0x10,
				// flag
				0xc0,
				// array extra data
				0x81,
				// type info
				0x18, 0x2a,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x14,
				// CBOR encoded array elements
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			// (data slab) next: 0, data: [0]
			id2: {
				// version
				0x10,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2b,

				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}
		storage := newTestPersistentStorageWithData(t, originalData)

		array, err := atree.NewArrayWithRootID(storage, id1)
		require.NoError(t, err)

		storable, err := array.Set(uint64(0), test_utils.NewStringValue("bbbbbbbbbbbbbbbbbbbbbb"))
		require.NoError(t, err)
		require.NotNil(t, storable)

		iterator, err := storage.SlabIterator()
		require.NoError(t, err)

		count := 0
		for {
			id, slab := iterator()
			if id == atree.SlabIDUndefined {
				break
			}

			encodedSlab, err := atree.EncodeSlab(slab, atree.GetCBOREncMode(storage))
			require.NoError(t, err)

			require.Equal(t, modifiedData[id], encodedSlab)
			count++
		}
		require.Equal(t, len(originalData), count)
	})
}

func TestPersistentStorageGenerateSlabID(t *testing.T) {
	baseStorage := test_utils.NewInMemBaseStorage()
	storage := atree.NewPersistentSlabStorage(baseStorage, nil, nil, nil, nil)

	t.Run("temp address", func(t *testing.T) {
		address := atree.Address{}

		id, err := storage.GenerateSlabID(address)
		require.NoError(t, err)
		require.Equal(t, address, id.Address())
		require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}, id.Index())

		id, err = storage.GenerateSlabID(address)
		require.NoError(t, err)
		require.Equal(t, address, id.Address())
		require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2}, id.Index())
	})
	t.Run("perm address", func(t *testing.T) {
		address := atree.Address{1}

		id, err := storage.GenerateSlabID(address)
		require.NoError(t, err)
		require.Equal(t, address, id.Address())
		require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1}, id.Index())

		id, err = storage.GenerateSlabID(address)
		require.NoError(t, err)
		require.Equal(t, address, id.Address())
		require.Equal(t, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2}, id.Index())
	})
}

func generateRandomSlab(id atree.SlabID, r *rand.Rand) atree.Slab {
	storable := test_utils.Uint64Value(r.Uint64())
	return atree.NewArrayRootDataSlab(id, []atree.Storable{storable})
}

func generateLargeSlab(id atree.SlabID) atree.Slab {

	const elementCount = 100

	storables := make([]atree.Storable, elementCount)
	for i := range storables {
		storable := test_utils.Uint64Value(uint64(i))
		storables[i] = storable
	}

	return atree.NewArrayRootDataSlab(id, storables)
}

func generateRandomAddress(r *rand.Rand) atree.Address {
	address := atree.Address{}
	r.Read(address[:])
	return address
}

type accessOrderTrackerBaseStorage struct {
	segTouchOrder []atree.SlabID
	indexReqOrder []atree.Address
	segments      map[atree.SlabID][]byte
	storageIndex  map[atree.Address]atree.SlabIndex
}

func newAccessOrderTrackerBaseStorage() *accessOrderTrackerBaseStorage {
	return &accessOrderTrackerBaseStorage{
		segTouchOrder: make([]atree.SlabID, 0),
		indexReqOrder: make([]atree.Address, 0),
		segments:      make(map[atree.SlabID][]byte),
		storageIndex:  make(map[atree.Address]atree.SlabIndex),
	}
}

func (s *accessOrderTrackerBaseStorage) SegTouchOrder() []atree.SlabID {
	return s.segTouchOrder
}

func (s *accessOrderTrackerBaseStorage) Retrieve(id atree.SlabID) ([]byte, bool, error) {
	s.segTouchOrder = append(s.segTouchOrder, id)
	seg, ok := s.segments[id]
	return seg, ok, nil
}

func (s *accessOrderTrackerBaseStorage) Store(id atree.SlabID, data []byte) error {
	s.segTouchOrder = append(s.segTouchOrder, id)
	s.segments[id] = data
	return nil
}

func (s *accessOrderTrackerBaseStorage) Remove(id atree.SlabID) error {
	s.segTouchOrder = append(s.segTouchOrder, id)
	delete(s.segments, id)
	return nil
}

func (s *accessOrderTrackerBaseStorage) GenerateSlabID(address atree.Address) (atree.SlabID, error) {
	s.indexReqOrder = append(s.indexReqOrder, address)

	index := s.storageIndex[address]
	nextIndex := index.Next()

	s.storageIndex[address] = nextIndex
	return atree.NewSlabID(address, nextIndex), nil
}

func (s *accessOrderTrackerBaseStorage) SegmentCounts() int { return len(s.segments) }

func (s *accessOrderTrackerBaseStorage) Size() int { return 0 }

func (s *accessOrderTrackerBaseStorage) BytesRetrieved() int { return 0 }

func (s *accessOrderTrackerBaseStorage) BytesStored() int { return 0 }

func (s *accessOrderTrackerBaseStorage) SegmentsReturned() int { return 0 }

func (s *accessOrderTrackerBaseStorage) SegmentsUpdated() int { return 0 }

func (s *accessOrderTrackerBaseStorage) SegmentsTouched() int { return 0 }

func (s *accessOrderTrackerBaseStorage) ResetReporter() {}

type testLedger struct {
	values map[string][]byte
	index  map[string]atree.SlabIndex
}

var _ atree.Ledger = &testLedger{}

func newTestLedger() *testLedger {
	return &testLedger{
		values: make(map[string][]byte),
		index:  make(map[string]atree.SlabIndex),
	}
}

func (l *testLedger) GetValue(owner, key []byte) (value []byte, err error) {
	value = l.values[l.key(owner, key)]
	return value, nil
}

func (l *testLedger) SetValue(owner, key, value []byte) (err error) {
	l.values[l.key(owner, key)] = value
	return nil
}

func (l *testLedger) ValueExists(owner, key []byte) (exists bool, err error) {
	value := l.values[l.key(owner, key)]
	return len(value) > 0, nil
}

func (l *testLedger) AllocateSlabIndex(owner []byte) (atree.SlabIndex, error) {
	index := l.index[string(owner)]
	next := index.Next()
	l.index[string(owner)] = next
	return next, nil
}

func (l *testLedger) key(owner, key []byte) string {
	return strings.Join([]string{string(owner), string(key)}, "|")
}

type ledgerIterationFunc func() (owner, key, value []byte)

func (l *testLedger) Iterator() ledgerIterationFunc {
	keys := make([]string, 0, len(l.values))
	for k := range l.values {
		keys = append(keys, k)
	}

	i := 0
	return func() (owner, key, value []byte) {
		if i >= len(keys) {
			return nil, nil, nil
		}

		s := strings.Split(keys[i], "|")
		owner, key = []byte(s[0]), []byte(s[1])
		value = l.values[keys[i]]
		i++
		return owner, key, value
	}
}

func (l *testLedger) Count() int {
	return len(l.values)
}

var errEncodeNonStorable = errors.New("failed to encode non-storable")

// nonStorable can't be encoded successfully.
type nonStorable struct{}

func (nonStorable) Encode(_ *atree.Encoder) error {
	return errEncodeNonStorable
}

func (nonStorable) ByteSize() uint32 {
	return 1
}

func (v nonStorable) StoredValue(_ atree.SlabStorage) (atree.Value, error) {
	return v, nil
}

func (nonStorable) ChildStorables() []atree.Storable {
	return nil
}

func (v nonStorable) Storable(_ atree.SlabStorage, _ atree.Address, _ uint64) (atree.Storable, error) {
	return v, nil
}

type slowStorable struct {
	test_utils.Uint8Value
}

func newSlowStorable(i uint8) slowStorable {
	return slowStorable{test_utils.Uint8Value(i)}
}

// slowStorable.Encode is used to reproduce a
// panic. It needs to be slow enough
// when called by FastCommit() compared to
// to a non-slow Encode function returning an error.
// See Atree issue #240.
func (s slowStorable) Encode(encoder *atree.Encoder) error {
	// Use division in a loop to slow down this function
	n := 1.0
	for i := range 2000 {
		n = (n + float64(i)) / 3.14
	}
	runtime.KeepAlive(n)
	return s.Uint8Value.Encode(encoder)
}

func TestFixLoadedBrokenReferences(t *testing.T) {
	address := atree.Address{1, 2, 3, 4, 5, 6, 7, 8}

	t.Run("healthy", func(t *testing.T) {

		// Create a health storage with arrays and maps
		mapMetaDataRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		mapDataNonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		mapDataNonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})
		nestedArrayID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		emptyMapDataRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 5})

		mapDataRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 6})

		emptyArrayDataRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 7})

		arrayDataRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 8})

		arrayMetaDataRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 9})
		arrayDataNonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 10})
		arrayDataNonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 11})
		nestedArrayID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 12})

		rootIDs := []atree.SlabID{
			mapMetaDataRootID,
			emptyMapDataRootID,
			mapDataRootID,
			emptyArrayDataRootID,
			arrayDataRootID,
			arrayMetaDataRootID,
		}

		data := map[atree.SlabID][]byte{
			// root map metadata slab
			// metadata slab
			mapMetaDataRootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			mapDataNonRootID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			mapDataNonRootID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:atree.SlabID(1,2,3,4,5,6,7,8,0,0,0,0,0,0,0,4)]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},

			// array data slab
			nestedArrayID: {
				// extra data
				// version
				0x00,
				// flag: root + array data
				0x80,
				// extra data (CBOR encoded array of 1 elements)
				0x81,
				// type info
				0x18, 0x2b,

				// version
				0x00,
				// flag: root + array data
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},

			// empty map
			emptyMapDataRootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},

			// root map data slab
			mapDataRootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):uint64(0)]
				0x82, 0xd8, 0xa4, 0x00, 0xd8, 0xa4, 0x00,
			},

			// empty array
			emptyArrayDataRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x00,
			},

			// root array data slab
			arrayDataRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},

			// root array metadata slab
			// (metadata slab) headers: [{id:2 size:228 count:9} {id:3 size:270 count:11} ]
			arrayMetaDataRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x81,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array meta data slab flag
				0x81,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, count, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
				0x00, 0x00, 0x00, 0x09,
				0x00, 0x00, 0x00, 0xe4,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
				0x00, 0x00, 0x00, 0x0b,
				0x00, 0x00, 0x01, 0x0e,
			},

			// (data slab) next: 3, data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			arrayDataNonRootID1: {
				// version
				0x00,
				// array data slab flag
				0x00,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x09,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},

			// (data slab) next: 0, data: [aaaaaaaaaaaaaaaaaaaaaa ... atree.SlabID(...)]
			arrayDataNonRootID2: {
				// version
				0x00,
				// array data slab flag
				0x40,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x0b,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
			},

			// (data slab) next: 0, data: [0]
			nestedArrayID2: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2b,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		rootIDSet, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, len(rootIDs), len(rootIDSet))

		for _, rootID := range rootIDs {
			_, found := rootIDSet[rootID]
			require.True(t, found)
		}

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, 0, len(skippedRootIDs))

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Fix broken reference
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, 0, len(skippedRootIDs))

		// No data is modified during fixing broken reference
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check health after fixing broken reference
		rootIDSet, err = atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, len(rootIDs), len(rootIDSet))

	})

	t.Run("broken root map data slab", func(t *testing.T) {

		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})

		brokenRefs := map[atree.SlabID][]atree.SlabID{
			rootID: {rootID},
		}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [atree.SlabID(0x0.1):uint64(0)]
				0x82,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				0xd8, 0xa4, 0x00,
			},
		}

		fixedData := map[atree.SlabID][]byte{
			rootID: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		_, err := atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab (0x0.1) not found: slab not found during slab iteration")

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, len(brokenRefs), len(skippedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, skippedRootIDs[rootID])
		}

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Fix broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, len(brokenRefs), len(fixedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, fixedRootIDs[rootID])
		}

		require.Equal(t, 0, len(skippedRootIDs))
		require.Equal(t, 1, GetDeltasCount(storage))

		// Check health after fixing broken reference
		rootIDs, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, 1, len(rootIDs))

		_, ok := rootIDs[rootID]
		require.True(t, ok)

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check encoded data
		baseStorage := atree.GetBaseStorage(storage).(*test_utils.InMemBaseStorage)
		require.Equal(t, 1, baseStorage.SegmentCounts())

		savedData, found, err := baseStorage.Retrieve(rootID)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[rootID], savedData)
	})

	t.Run("broken nested storable in root map data slab", func(t *testing.T) {

		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})

		brokenRefs := map[atree.SlabID][]atree.SlabID{
			rootID: {rootID},
		}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):SomeValue(atree.SlabID(0x0.1))]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, test_utils.CBORTagSomeValue, 0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			},
		}

		fixedData := map[atree.SlabID][]byte{
			rootID: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		_, err := atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab (0x0.1) not found: slab not found during slab iteration")

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, len(brokenRefs), len(skippedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, skippedRootIDs[rootID])
		}

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Fix broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, len(brokenRefs), len(fixedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, fixedRootIDs[rootID])
		}

		require.Equal(t, 0, len(skippedRootIDs))
		require.Equal(t, 1, GetDeltasCount(storage))

		// Check health after fixing broken reference
		rootIDs, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, 1, len(rootIDs))

		_, ok := rootIDs[rootID]
		require.True(t, ok)

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check encoded data
		baseStorage := atree.GetBaseStorage(storage).(*test_utils.InMemBaseStorage)
		require.Equal(t, 1, baseStorage.SegmentCounts())

		savedData, found, err := baseStorage.Retrieve(rootID)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[rootID], savedData)
	})

	t.Run("broken non-root map data slab", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootDataID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootDataID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		brokenRefs := map[atree.SlabID][]atree.SlabID{
			rootID: {nonRootDataID2},
		}

		// Expected serialized slab data with storage id
		data := map[atree.SlabID][]byte{

			// metadata slab
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootDataID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			nonRootDataID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:atree.SlabID(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			},
		}

		fixedData := map[atree.SlabID][]byte{
			rootID: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		_, err := atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab (0x0.1) not found: slab not found during slab iteration")

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, len(brokenRefs), len(skippedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, skippedRootIDs[rootID])
		}

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Fix broken reference
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, 1, len(fixedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, fixedRootIDs[rootID])
		}

		require.Equal(t, 0, len(skippedRootIDs))
		require.Equal(t, 3, GetDeltasCount(storage))

		// Check health after fixing broken reference
		rootIDs, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, 1, len(rootIDs))

		_, ok := rootIDs[rootID]
		require.True(t, ok)

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check encoded data
		baseStorage := atree.GetBaseStorage(storage).(*test_utils.InMemBaseStorage)
		require.Equal(t, 1, baseStorage.SegmentCounts())

		savedData, found, err := baseStorage.Retrieve(rootID)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[rootID], savedData)
	})

	t.Run("multiple data slabs with broken reference in the same map", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootDataID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootDataID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		brokenRefs := map[atree.SlabID][]atree.SlabID{
			rootID: {nonRootDataID1, nonRootDataID2},
		}

		data := map[atree.SlabID][]byte{

			// metadata slab
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootDataID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:atree.SlabID(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			},

			// data slab
			nonRootDataID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:atree.SlabID(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2)]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},
		}

		fixedData := map[atree.SlabID][]byte{
			rootID: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		_, err := atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab not found during slab iteration")

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, len(brokenRefs), len(skippedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, skippedRootIDs[rootID])
		}

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Fix broken reference
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, len(brokenRefs), len(fixedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, fixedRootIDs[rootID])
		}

		require.Equal(t, 0, len(skippedRootIDs))
		require.Equal(t, 3, GetDeltasCount(storage))

		// Check health after fixing broken reference
		rootIDs, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, 1, len(rootIDs))

		_, ok := rootIDs[rootID]
		require.True(t, ok)

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check encoded data
		baseStorage := atree.GetBaseStorage(storage).(*test_utils.InMemBaseStorage)
		require.Equal(t, 1, baseStorage.SegmentCounts())

		savedData, found, err := baseStorage.Retrieve(rootID)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[rootID], savedData)
	})

	t.Run("broken reference in nested container", func(t *testing.T) {
		parentContainerRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootDataID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootDataID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})
		nestedContainerRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		brokenRefs := map[atree.SlabID][]atree.SlabID{
			nestedContainerRootID: {nestedContainerRootID},
		}

		data := map[atree.SlabID][]byte{

			// metadata slab
			parentContainerRootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootDataID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			nonRootDataID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:atree.SlabID(1,2,3,4,5,6,7,8,0,0,0,0,0,0,0,4)]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},

			// map data slab
			nestedContainerRootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):atree.SlabID(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			},
		}

		fixedData := map[atree.SlabID][]byte{
			// map data slab
			nestedContainerRootID: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		_, err := atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab (0x0.1) not found: slab not found during slab iteration")

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, len(brokenRefs), len(skippedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, skippedRootIDs[rootID])
		}

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Fix broken reference
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, len(brokenRefs), len(fixedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, fixedRootIDs[rootID])
		}

		require.Equal(t, 0, len(skippedRootIDs))
		require.Equal(t, 1, GetDeltasCount(storage))

		// Check health after fixing broken reference
		rootIDs, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, 1, len(rootIDs))

		_, ok := rootIDs[parentContainerRootID]
		require.True(t, ok)

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check encoded data
		baseStorage := atree.GetBaseStorage(storage).(*test_utils.InMemBaseStorage)
		require.Equal(t, 4, baseStorage.SegmentCounts())

		savedData, found, err := baseStorage.Retrieve(nestedContainerRootID)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[nestedContainerRootID], savedData)
	})

	t.Run("selectively fix maps", func(t *testing.T) {
		rootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootDataID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootDataID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3}) // containing broken ref

		rootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4}) // containing broken ref

		rootIDs := []atree.SlabID{rootID1, rootID2}

		brokenRefs := map[atree.SlabID][]atree.SlabID{
			rootID1: {nonRootDataID2},
			rootID2: {rootID2},
		}

		data := map[atree.SlabID][]byte{
			// metadata slab
			rootID1: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootDataID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			nonRootDataID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:atree.SlabID(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			},

			// map data slab
			rootID2: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x4a,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):atree.SlabID(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, 0xff, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
			},
		}

		fixedData := map[atree.SlabID][]byte{
			rootID1: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},

			rootID2: {
				// version
				0x10,
				// flag: root + map data
				0x88,

				// extra data
				// CBOR encoded array of 3 elements
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x4a,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x59, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x99, 0x00, 0x00,
			},
		}

		storage := newTestPersistentStorageWithData(t, data)

		// Load data in storage
		for id := range data {
			_, found, err := storage.Retrieve(id)
			require.NoError(t, err)
			require.True(t, found)
		}

		// Check health before fixing broken reference
		_, err := atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab not found during slab iteration")

		var fixedRootIDs map[atree.SlabID][]atree.SlabID
		var skippedRootIDs map[atree.SlabID][]atree.SlabID

		// Don't fix any broken references
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(_ atree.Value) bool {
			return false
		})
		require.NoError(t, err)
		require.Equal(t, 0, len(fixedRootIDs))
		require.Equal(t, len(brokenRefs), len(skippedRootIDs))

		for rootID, slabIDsWithBrokenRef := range brokenRefs {
			require.ElementsMatch(t, slabIDsWithBrokenRef, skippedRootIDs[rootID])
		}

		// No data is modified because no fix happened
		require.Equal(t, 0, GetDeltasCount(storage))

		// Only fix one map with broken reference
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(v atree.Value) bool {
			m, ok := v.(*atree.OrderedMap)
			require.True(t, ok)
			return rootID1 == m.SlabID()
		})
		require.NoError(t, err)
		require.Equal(t, 1, len(fixedRootIDs))
		require.Equal(t, brokenRefs[rootID1], fixedRootIDs[rootID1])
		require.Equal(t, 1, len(skippedRootIDs))
		require.Equal(t, brokenRefs[rootID2], skippedRootIDs[rootID2])
		require.Equal(t, 3, GetDeltasCount(storage))

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check health after only fixing one map with broken reference
		_, err = atree.CheckStorageHealth(storage, -1)
		require.ErrorContains(t, err, "slab not found during slab iteration")

		// Fix remaining map with broken reference
		fixedRootIDs, skippedRootIDs, err = storage.FixLoadedBrokenReferences(func(atree.Value) bool {
			return true
		})
		require.NoError(t, err)
		require.Equal(t, 1, len(fixedRootIDs))
		require.Equal(t, brokenRefs[rootID2], fixedRootIDs[rootID2])
		require.Equal(t, 0, len(skippedRootIDs))
		require.Equal(t, 1, GetDeltasCount(storage))

		// Check health after fixing remaining maps with broken reference
		returnedRootIDs, err := atree.CheckStorageHealth(storage, -1)
		require.NoError(t, err)
		require.Equal(t, len(rootIDs), len(returnedRootIDs))

		// Save data in storage
		err = storage.FastCommit(runtime.NumCPU())
		require.NoError(t, err)
		require.Equal(t, 0, GetDeltasCount(storage))

		// Check encoded data
		baseStorage := atree.GetBaseStorage(storage).(*test_utils.InMemBaseStorage)
		require.Equal(t, 2, baseStorage.SegmentCounts())

		savedData, found, err := baseStorage.Retrieve(rootID1)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[rootID1], savedData)

		savedData, found, err = baseStorage.Retrieve(rootID2)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, fixedData[rootID2], savedData)
	})
}

func TestGetAllChildReferencesFromArray(t *testing.T) {
	address := atree.Address{1, 2, 3, 4, 5, 6, 7, 8}

	t.Run("empty", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})

		expectedRefIDs := []atree.SlabID{}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab without refs", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})

		expectedRefIDs := []atree.SlabID{}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab with ref to nested element", func(t *testing.T) {
		parentRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		expectedRefIDs := []atree.SlabID{childRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			parentRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, parentRootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab with ref in nested storable", func(t *testing.T) {
		parentRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		expectedRefIDs := []atree.SlabID{childRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			parentRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, test_utils.CBORTagSomeValue, 0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, parentRootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab with broken ref", func(t *testing.T) {
		parentRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		expectedRefIDs := []atree.SlabID{}
		expectedBrokenRefIDs := []atree.SlabID{childRootID}

		data := map[atree.SlabID][]byte{
			parentRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},
		}

		testGetAllChildReferences(t, data, parentRootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		expectedRefIDs := []atree.SlabID{nonRootID1, nonRootID2}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x81,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array meta data slab flag
				0x81,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, count, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x09,
				0x00, 0x00, 0x00, 0xe4,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x0b,
				0x00, 0x00, 0x01, 0x0e,
			},

			// (data slab) next: 3, data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			nonRootID1: {
				// version
				0x00,
				// array data slab flag
				0x00,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x09,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},

			// (data slab) next: 0, data: [aaaaaaaaaaaaaaaaaaaaaa ... atree.SlabID(...)]
			nonRootID2: {
				// version
				0x00,
				// array data slab flag
				0x40,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x0b,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab with broken ref to first data slab", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		expectedRefIDs := []atree.SlabID{nonRootID2}
		expectedBrokenRefIDs := []atree.SlabID{nonRootID1}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x81,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array meta data slab flag
				0x81,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, count, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x09,
				0x00, 0x00, 0x00, 0xe4,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x0b,
				0x00, 0x00, 0x01, 0x0e,
			},

			// (data slab) next: 0, data: [aaaaaaaaaaaaaaaaaaaaaa ... atree.SlabID(...)]
			nonRootID2: {
				// version
				0x00,
				// array data slab flag
				0x40,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x0b,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab with ref", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		expectedRefIDs := []atree.SlabID{nonRootID1, nonRootID2, childRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x81,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array meta data slab flag
				0x81,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, count, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x09,
				0x00, 0x00, 0x00, 0xe4,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x0b,
				0x00, 0x00, 0x01, 0x0e,
			},

			// (data slab) next: 3, data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			nonRootID1: {
				// version
				0x00,
				// array data slab flag
				0x00,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x09,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},

			// (data slab) next: 0, data: [aaaaaaaaaaaaaaaaaaaaaa ... atree.SlabID(...)]
			nonRootID2: {
				// version
				0x00,
				// array data slab flag
				0x40,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x0b,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab with broken ref to nested element", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		expectedRefIDs := []atree.SlabID{nonRootID1, nonRootID2}
		expectedBrokenRefIDs := []atree.SlabID{childRootID}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x81,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array meta data slab flag
				0x81,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, count, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x09,
				0x00, 0x00, 0x00, 0xe4,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x0b,
				0x00, 0x00, 0x01, 0x0e,
			},

			// (data slab) next: 3, data: [aaaaaaaaaaaaaaaaaaaaaa ... aaaaaaaaaaaaaaaaaaaaaa]
			nonRootID1: {
				// version
				0x00,
				// array data slab flag
				0x00,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x09,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
			},

			// (data slab) next: 0, data: [aaaaaaaaaaaaaaaaaaaaaa ... atree.SlabID(...)]
			nonRootID2: {
				// version
				0x00,
				// array data slab flag
				0x40,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x0b,
				// CBOR encoded array elements
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("3-level of nested containers", func(t *testing.T) {
		parentRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		gchildRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		expectedRefIDs := []atree.SlabID{childRootID, gchildRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			parentRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
			},

			gchildRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, parentRootID, expectedRefIDs, expectedBrokenRefIDs)
	})
}

func TestGetAllChildReferencesFromMap(t *testing.T) {
	address := atree.Address{1, 2, 3, 4, 5, 6, 7, 8}

	t.Run("empty", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})

		expectedRefIDs := []atree.SlabID{}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab without refs", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})

		expectedRefIDs := []atree.SlabID{}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):uint64(0)]
				0x82, 0xd8, 0xa4, 0x00, 0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab with ref", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		expectedRefIDs := []atree.SlabID{childRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):uint64(0)]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab with ref in nested storable", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		expectedRefIDs := []atree.SlabID{childRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):uint64(0)]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, test_utils.CBORTagSomeValue, 0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root data slab with broken ref", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})

		expectedRefIDs := []atree.SlabID{}
		expectedBrokenRefIDs := []atree.SlabID{childRootID}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):uint64(0)]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		expectedRefIDs := []atree.SlabID{nonRootID1, nonRootID2}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			// metadata slab
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			nonRootID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:hhhhhhhhhhhhhhhhhhhhhh]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab with broken ref to first data slab", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		expectedRefIDs := []atree.SlabID{nonRootID2}
		expectedBrokenRefIDs := []atree.SlabID{nonRootID1}

		data := map[atree.SlabID][]byte{
			// metadata slab
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:hhhhhhhhhhhhhhhhhhhhhh]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab with ref", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		expectedRefIDs := []atree.SlabID{nonRootID1, nonRootID2, childRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			// metadata slab
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			nonRootID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:hhhhhhhhhhhhhhhhhhhhhh]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 0
				0x00,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 0 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("root metadata slab with broken ref to nested element", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		nonRootID1 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		nonRootID2 := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 4})

		expectedRefIDs := []atree.SlabID{nonRootID1, nonRootID2}
		expectedBrokenRefIDs := []atree.SlabID{childRootID}

		data := map[atree.SlabID][]byte{
			// metadata slab
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map meta
				0x89,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info: "map"
				0x18, 0x2A,
				// count: 8
				0x08,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + meta
				0x89,
				// child header count
				0x00, 0x02,
				// child header 1 (storage id, first key, size)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x01, 0x02,
				// child header 2
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				0x00, 0x00, 0x00, 0xfe,
			},

			// data slab
			nonRootID1: {
				// version
				0x00,
				// flag: map data
				0x08,
				// next storage id
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// hkey: 1
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// hkey: 2
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
				// hkey: 3
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [aaaaaaaaaaaaaaaaaaaaaa:aaaaaaaaaaaaaaaaaaaaaa]
				0x82,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				0x76, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x61,
				// element: [bbbbbbbbbbbbbbbbbbbbbb:bbbbbbbbbbbbbbbbbbbbbb]
				0x82,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				0x76, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62,
				// element: [cccccccccccccccccccccc:cccccccccccccccccccccc]
				0x82,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				0x76, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
				// element: [dddddddddddddddddddddd:dddddddddddddddddddddd]
				0x82,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
				0x76, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64,
			},

			// data slab
			nonRootID2: {
				// version
				0x00,
				// flag: has pointer + map data
				0x48,
				// next storage id
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 4)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
				// hkey: 4
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// hkey: 5
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05,
				// hkey: 6
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
				// hkey: 7
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,

				// elements (array of 4 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
				// element: [eeeeeeeeeeeeeeeeeeeeee:eeeeeeeeeeeeeeeeeeeeee]
				0x82,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				0x76, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65, 0x65,
				// element: [ffffffffffffffffffffff:ffffffffffffffffffffff]
				0x82,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				0x76, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
				// element: [gggggggggggggggggggggg:gggggggggggggggggggggg]
				0x82,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				0x76, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
				// element: [hhhhhhhhhhhhhhhhhhhhhh:hhhhhhhhhhhhhhhhhhhhhh]
				0x82,
				0x76, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68, 0x68,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})

	t.Run("3-level containers", func(t *testing.T) {
		rootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 1})
		childRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 2})
		gchildRootID := atree.NewSlabID(address, atree.SlabIndex{0, 0, 0, 0, 0, 0, 0, 3})

		expectedRefIDs := []atree.SlabID{childRootID, gchildRootID}
		expectedBrokenRefIDs := []atree.SlabID{}

		data := map[atree.SlabID][]byte{
			rootID: {
				// extra data
				// version
				0x00,
				// flag: root + map data
				0x88,
				// extra data (CBOR encoded array of 3 elements)
				0x83,
				// type info
				0x18, 0x2a,
				// count: 1
				0x01,
				// seed
				0x1b, 0x52, 0xa8, 0x78, 0x3, 0x85, 0x2c, 0xaa, 0x49,

				// version
				0x00,
				// flag: root + map data
				0x88,

				// the following encoded data is valid CBOR

				// elements (array of 3 elements)
				0x83,

				// level: 0
				0x00,

				// hkeys (byte string of length 8 * 1)
				0x5b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
				// hkey: 0
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

				// elements (array of 1 elements)
				// each element is encoded as CBOR array of 2 elements (key, value)
				0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
				// element: [uint64(0):uint64(0)]
				0x82,
				0xd8, 0xa4, 0x00,
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
			},

			childRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xff, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
			},

			gchildRootID: {
				// extra data
				// version
				0x00,
				// extra data flag
				0x80,
				// array of extra data
				0x81,
				// type info
				0x18, 0x2a,

				// version
				0x00,
				// array data slab flag
				0x80,
				// CBOR encoded array head (fixed size 3 byte)
				0x99, 0x00, 0x01,
				// CBOR encoded array elements
				0xd8, 0xa4, 0x00,
			},
		}

		testGetAllChildReferences(t, data, rootID, expectedRefIDs, expectedBrokenRefIDs)
	})
}

func testGetAllChildReferences(
	t *testing.T,
	data map[atree.SlabID][]byte,
	rootID atree.SlabID,
	expectedRefIDs []atree.SlabID,
	expectedBrokenRefIDs []atree.SlabID,
) {
	storage := newTestPersistentStorageWithData(t, data)

	refs, brokenRefs, err := storage.GetAllChildReferences(rootID)
	require.NoError(t, err)

	require.Equal(t, len(expectedRefIDs), len(refs))
	require.ElementsMatch(t, expectedRefIDs, refs)

	require.Equal(t, len(expectedBrokenRefIDs), len(brokenRefs))
	require.ElementsMatch(t, expectedBrokenRefIDs, brokenRefs)
}

func TestStorageNondeterministicFastCommit(t *testing.T) {
	t.Run("0 slabs", func(t *testing.T) {
		numberOfAccounts := 0
		numberOfSlabsPerAccount := 0
		testStorageNondeterministicFastCommit(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("1 slabs", func(t *testing.T) {
		numberOfAccounts := 1
		numberOfSlabsPerAccount := 1
		testStorageNondeterministicFastCommit(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("10 slabs", func(t *testing.T) {
		numberOfAccounts := 1
		numberOfSlabsPerAccount := 10
		testStorageNondeterministicFastCommit(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("100 slabs", func(t *testing.T) {
		numberOfAccounts := 10
		numberOfSlabsPerAccount := 10
		testStorageNondeterministicFastCommit(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("10_000 slabs", func(t *testing.T) {
		numberOfAccounts := 10
		numberOfSlabsPerAccount := 1_000
		testStorageNondeterministicFastCommit(t, numberOfAccounts, numberOfSlabsPerAccount)
	})
}

func testStorageNondeterministicFastCommit(t *testing.T, numberOfAccounts int, numberOfSlabsPerAccount int) {
	encMode, err := cbor.EncOptions{}.EncMode()
	require.NoError(t, err)

	decMode, err := cbor.DecOptions{}.DecMode()
	require.NoError(t, err)

	r := newRand(t)

	baseStorage := test_utils.NewInMemBaseStorage()
	storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, nil, nil)

	encodedSlabs := make(map[atree.SlabID][]byte)
	slabSize := uint64(0)

	// Storage slabs
	for range numberOfAccounts {

		addr := generateRandomAddress(r)

		for range numberOfSlabsPerAccount {

			slabID, err := storage.GenerateSlabID(addr)
			require.NoError(t, err)

			slab := generateRandomSlab(slabID, r)
			slabSize += uint64(slab.ByteSize())

			err = storage.Store(slabID, slab)
			require.NoError(t, err)

			// capture data for accuracy testing
			encodedSlabs[slabID], err = atree.EncodeSlab(slab, encMode)
			require.NoError(t, err)
		}
	}

	require.Equal(t, uint(len(encodedSlabs)), storage.DeltasWithoutTempAddresses())
	require.Equal(t, slabSize, storage.DeltasSizeWithoutTempAddresses())

	// Commit deltas
	err = storage.NondeterministicFastCommit(10)
	require.NoError(t, err)

	require.Equal(t, uint(0), storage.DeltasWithoutTempAddresses())
	require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
	require.Equal(t, len(encodedSlabs), storage.Count())

	// Compare encoded data
	for sid, value := range encodedSlabs {
		storedValue, found, err := baseStorage.Retrieve(sid)
		require.NoError(t, err)
		require.True(t, found)
		require.Equal(t, value, storedValue)
	}

	// Remove all slabs from storage
	for sid := range encodedSlabs {
		err = storage.Remove(sid)
		require.NoError(t, err)
		require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())
	}

	// Commit deltas
	err = storage.NondeterministicFastCommit(10)
	require.NoError(t, err)

	require.Equal(t, 0, storage.Count())
	require.Equal(t, uint64(0), storage.DeltasSizeWithoutTempAddresses())

	// Check remove functionality
	for sid := range encodedSlabs {
		storedValue, found, err := storage.Retrieve(sid)
		require.NoError(t, err)
		require.False(t, found)
		require.Nil(t, storedValue)
	}
}

func TestStorageBatchPreload(t *testing.T) {
	t.Run("0 slab", func(t *testing.T) {
		numberOfAccounts := 0
		numberOfSlabsPerAccount := 0
		testStorageBatchPreload(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("1 slab", func(t *testing.T) {
		numberOfAccounts := 1
		numberOfSlabsPerAccount := 1
		testStorageBatchPreload(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("10 slab", func(t *testing.T) {
		numberOfAccounts := 1
		numberOfSlabsPerAccount := 10
		testStorageBatchPreload(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("100 slabs", func(t *testing.T) {
		numberOfAccounts := 10
		numberOfSlabsPerAccount := 10
		testStorageBatchPreload(t, numberOfAccounts, numberOfSlabsPerAccount)
	})

	t.Run("10_000 slabs", func(t *testing.T) {
		numberOfAccounts := 10
		numberOfSlabsPerAccount := 1_000
		testStorageBatchPreload(t, numberOfAccounts, numberOfSlabsPerAccount)
	})
}

func testStorageBatchPreload(t *testing.T, numberOfAccounts int, numberOfSlabsPerAccount int) {

	indexesByAddress := make(map[atree.Address]uint64)

	generateSlabID := func(address atree.Address) atree.SlabID {
		nextIndex := indexesByAddress[address] + 1

		var idx atree.SlabIndex
		binary.BigEndian.PutUint64(idx[:], nextIndex)

		indexesByAddress[address] = nextIndex

		return atree.NewSlabID(address, idx)
	}

	encMode, err := cbor.EncOptions{}.EncMode()
	require.NoError(t, err)

	decMode, err := cbor.DecOptions{}.DecMode()
	require.NoError(t, err)

	r := newRand(t)

	encodedSlabs := make(map[atree.SlabID][]byte)

	// Generate and encode slabs
	for range numberOfAccounts {

		addr := generateRandomAddress(r)

		for range numberOfSlabsPerAccount {

			slabID := generateSlabID(addr)

			slab := generateRandomSlab(slabID, r)

			encodedSlabs[slabID], err = atree.EncodeSlab(slab, encMode)
			require.NoError(t, err)
		}
	}

	baseStorage := test_utils.NewInMemBaseStorageFromMap(encodedSlabs)
	storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, test_utils.DecodeStorable, test_utils.DecodeTypeInfo)

	ids := make([]atree.SlabID, 0, len(encodedSlabs))
	for id := range encodedSlabs {
		ids = append(ids, id)
	}

	// Batch preload slabs from base storage
	err = storage.BatchPreload(ids, runtime.NumCPU())
	require.NoError(t, err)
	require.Equal(t, len(encodedSlabs), GetCacheCount(storage))
	require.Equal(t, 0, GetDeltasCount(storage))

	// Compare encoded data
	for id, data := range encodedSlabs {
		cachedData, err := atree.EncodeSlab(atree.GetCache(storage)[id], encMode)
		require.NoError(t, err)

		require.Equal(t, cachedData, data)
	}
}

func TestStorageBatchPreloadNotFoundSlabs(t *testing.T) {

	encMode, err := cbor.EncOptions{}.EncMode()
	require.NoError(t, err)

	decMode, err := cbor.DecOptions{}.DecMode()
	require.NoError(t, err)

	r := newRand(t)

	t.Run("empty storage", func(t *testing.T) {
		const numberOfSlabs = 10

		ids := make([]atree.SlabID, numberOfSlabs)
		for i := range ids {
			var index atree.SlabIndex
			binary.BigEndian.PutUint64(index[:], uint64(i))

			ids[i] = atree.NewSlabID(generateRandomAddress(r), index)
		}

		baseStorage := test_utils.NewInMemBaseStorage()
		storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, test_utils.DecodeStorable, test_utils.DecodeTypeInfo)

		err := storage.BatchPreload(ids, runtime.NumCPU())
		require.NoError(t, err)

		require.Equal(t, 0, GetCacheCount(storage))
		require.Equal(t, 0, GetDeltasCount(storage))
	})

	t.Run("non-empty storage", func(t *testing.T) {
		const numberOfSlabs = 10

		ids := make([]atree.SlabID, numberOfSlabs)
		encodedSlabs := make(map[atree.SlabID][]byte)

		for i := range ids {
			var index atree.SlabIndex
			binary.BigEndian.PutUint64(index[:], uint64(i))

			id := atree.NewSlabID(generateRandomAddress(r), index)

			slab := generateRandomSlab(id, r)

			encodedSlabs[id], err = atree.EncodeSlab(slab, encMode)
			require.NoError(t, err)

			ids[i] = id
		}

		// Append a slab ID that doesn't exist in storage.
		ids = append(ids, atree.NewSlabID(generateRandomAddress(r), atree.SlabIndex{numberOfSlabs}))

		baseStorage := test_utils.NewInMemBaseStorageFromMap(encodedSlabs)
		storage := atree.NewPersistentSlabStorage(baseStorage, encMode, decMode, test_utils.DecodeStorable, test_utils.DecodeTypeInfo)

		err := storage.BatchPreload(ids, runtime.NumCPU())
		require.NoError(t, err)

		require.Equal(t, len(encodedSlabs), GetCacheCount(storage))
		require.Equal(t, 0, GetDeltasCount(storage))

		// Compare encoded data
		for id, data := range encodedSlabs {
			cachedData, err := atree.EncodeSlab(atree.GetCache(storage)[id], encMode)
			require.NoError(t, err)

			require.Equal(t, cachedData, data)
		}
	})
}
